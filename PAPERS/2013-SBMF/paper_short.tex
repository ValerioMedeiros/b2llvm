\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amssymb}
\usepackage[fleqn]{amsmath}
\usepackage[colorlinks=true]{hyperref}
\usepackage{xspace,framed,here,keystroke}
\pagestyle{headings}
\title{A Proposed Translation of B Implementations to the LLVM}
\author{David D\'{e}harbe \inst{1} \and Val\'{e}rio Medeiros Jr.\inst{2}}
\institute{Federal University of Rio Grande do Norte, UFRN, Brazil\\
\and 
Federal Institute of Education, Science and Technology  of Rio Grande do Norte, IFRN, Brazil}
\date{May 2013}



\newcommand{\trad}[2]{\ensuremath{\lVert \textsf{#1} \rVert^{\textit{#2}}}}
\newcommand{\nl}[0]{\text{\Return}}
\newcommand{\mty}[0]{\texttt{""}}
\DeclareMathOperator{\conc}{\diamond}
\DeclareMathOperator{\isdef}{\equiv}
\DeclareMathOperator{\dom}{\mbox{dom}}
\DeclareMathOperator{\name}{\mathcal{L}()}
\newcommand{\llvm}[1]{\texttt{#1}}
\newcommand{\B}[1]{\textsf{#1}}
\newcommand{\lalt}[0]{$\langle$\xspace}
\newcommand{\ralt}[0]{$\rangle$\xspace}
\newcommand{\alt}[0]{$\mid\,$}
\newcommand{\ListOf}[1]{$\mbox{#1}^+$}
\newcommand{\nt}[1]{{\normalfont\textit{#1}}}
\newcommand{\Dict}[0]{\mathbb{D}}
\newcommand{\Text}[0]{\mathbb{T}}
\newcommand{\IF}[0]{\textbf{ if }}
\newcommand{\ELSIF}[0]{\textbf{ else if }}
\newcommand{\ELSE}[0]{\textbf{ else }}
\newcommand{\THEN}[0]{\textbf{ then }}
\newcommand{\LET}[0]{\textbf{ let }}
\newcommand{\IN}[0]{\textbf{ in }}
\newcommand{\AND}[0]{\textbf{ and }}
\newcommand{\PH}[1]{\framebox{$#1$}}
\newcommand{\sep}[0]{\otimes}
\newcommand{\intf}[0]{\ensuremath{\mathbb{I}}}
\newcommand{\Global}[0]{\ensuremath{\sf\Gamma}}
\newcommand{\local}[0]{\ensuremath{\sf\lambda}}
\newcommand{\opmap}[0]{\ensuremath{\sf\Omega}}
\newcommand{\idx}[0]{\ensuremath{\sf\Pi}}
\newcommand{\state}[0]{\ensuremath{\sf\Sigma}}
\newcommand{\tradi}[2]{\ensuremath{\langle \textsf{#1} \rangle^{\textit{#2}}}}

\begin{document}
\maketitle

\begin{abstract}
The aim of this work is to lay the foundations of a multi-platform code
generator for the B method. In particular, this paper presents a proposed
translation  procedure from a subset of the B language for implementations
towards LLVM source code. This translation is defined formally as a set of
rules defined recursively on the abstract syntax for B implementations. It 
presents a overview of translation and a simplified example.
\end{abstract}

\section{Introduction}

B is a formal refinement-based software design method~\cite{Abrial1996}. It has
a single language encompassing abstract constructs suitable for specification,
as well as classic imperative constructs for computer programming. The starting
point of a B development is a specification, called a \emph{machine}, that is
incrementally refined to an \emph{implementation}, where only imperative-like
constructs may be employed~\cite{Clearsy}. Such implementation may then be
translated to source code in a programming language, say C~\cite{ComenC} or
Ada. All steps in the B method are formally verified using certified theorem
proving technologies. However the translation to some programming language and
its subsequent compilation to the target platform do not benefit from the same
mathematical rigor. In practice, redundancy in the tool chains and execution
platform are employed to increase the level of confidence to the desired levels.

The goal of this work is to connect the B method to the LLVM compilation
framework~\cite{Lattner04LLVM}.  LLVM is a free, open-source project upon which
many compiling contemporary technologies and tools are based. LLVM provides an
intermediate assembly language upon which may be applied techniques such as
optimization, static analysis, code generation, debugging, etc. Providing a
connection from the B method to this framework gives the users of the B method
access to these technologies. Our approach is to define a translation from B0
(the subset of the B language that is used to describe imperative programs) to
the LLVM intermediate format.

Considering the correctness of the proposed translation, we shall rely upon
human inspection for the time being. The standard uniform semantic framework for
B and LLVM that would be necessary to carry out a proof of this correctness does
not exist (yet). A possible approach to mitigate the risk of having an error in
the translation would be to include assertions in the target code. Indeed the
artifacts produced in the B development have many such assertions and it would
be possible to translate at least some of them (B has an assertion instruction
that introduces additional verification conditions in the development). The
produced code could then be (at least partially) verified by testing the absence
of assertion violations.

\paragraph{Overview.} Following this introduction, the paper is organized as
follows. The implementation constructs of the B language, and selected elements
of the LLVM are presented in section~\ref{sec:b-impl} and~\ref{sec:llvm}.
Section~\ref{sec:control} presents the main rules to translate the operations and
instructions. We conclude and discuss future work in~\ref{sec:conclusion}.

\section{Implementation Language in the B-method}
\label{sec:b-impl}

This section describes the B implementation constructs that are considered in
the compilation to the LLVM. This description introduces the notations used in
the definition of the translation. The elements of the B language are denoted
using a \B{sans serif} font. 

Figure~\ref{tab:node-attr} summarizes the structure
of the abstract syntax that is relevant in the definition of the proposed
translation and introduces identifiers used in the definition of the
translation. For instance, and for the purpose of the translation, the relevant
components of a B implementation are: \B{id}, the name identifying the
implementation within the project; \B{const}, a set of constant
names, their type and their values; \B{var}, a set of variable names, their
type and possibly additional functional restrictions forming the rest of the
state; \B{init}, a sequence of instructions executed upon initialization of
the implementation; \B{op}, a set of operations, each being an algorithmic 
description of the different functionalities provided by the implementation.

The operations are defined as (sequences of) instructions. Operations also
have a name, inputs and outputs. Possible instructions are the classic
imperative constructs: variable assignment, if and case conditional, while loop,
block with or without local variables, and operation calls. The if constructs
may have several branches, each with a condition as well as an optional else
branch. 

Note that the translation presented in this paper only considers types \B{INT}
(integer) and \B{BOOL} (Boolean). Accordingly, the expression language consists
in arithmetic operations \B{-} (unary and binary), \B{+}, \B{*}, \B{/}, \B{mod},
\B{succ} and \B{pred} and Boolean operations
\B{$\land$}, \B{$\lor$}, \B{$\neg$} as well as relations \B{=}, \B{$\neq$},
\B{$>$}, \B{$<$}, \B{$\leq$} and \B{$\neq$}. Atomic expressions are identifiers,
Boolean constants \B{FALSE} and \B{TRUE}, integer literals, and integer
constants \B{MAXINT} and \B{MININT}. The development through the application of
the B method ensures the absence of overflows and underflows.

\begin{figure}[H]
  \begin{center}
    {\footnotesize
      \frame{
    \begin{tabular}[t]{ccccc}
      \begin{tabular}[t]{rcl}
        \hline
        \multicolumn{3}{|c|}{Implementation: \B{Impl}} \\
        \hline
        \B{id} & : & \B{Name} \\
%        \B{see} & : & seq \B{Name} \\
%        \B{imp} & : & seq \B{Impo} \\
        \B{const} & : & seq \B{Cons} \\
        \B{var} & : & seq \B{Vari} \\
        \B{init} & : & \B{Inst} \\
        \B{op} & : & seq \B{Oper} \\
        \hline
        %\multicolumn{3}{|c|}{Imported machine: \B{Impo}} \\
        %\hline
        %\B{id} & : & \B{Name} \\
        %\B{pre} & : & opt \B{Name} \\
        %\hline
        \multicolumn{3}{|c|}{Constant: \B{Cons}} \\
        \hline
        \B{id} & : & \B{Name} \\
        \B{type} & : & \B{Type} \\
        \B{val} & : & \B{Value} \\
        \hline
        \multicolumn{3}{|c|}{Variable: \B{Vari}} \\
        \hline
        \B{id} & : & \B{Name} \\
        \B{type} & : & \B{Type} \\
        \B{scope} & : & \B{Impl} \alt \B{Oper}\\
        \hline
        \multicolumn{3}{|c|}{Operation: \B{Oper}} \\
        \hline
        \B{id} & : & \B{Name} \\
        \B{inp} & : & seq \B{Vari} \\
        \B{out} & : & seq \B{Vari} \\
        \B{body} & : & \B{Inst}	\\
      \end{tabular}
      & &
      \begin{tabular}[t]{rcl}
        \hline
        \multicolumn{3}{|c|}{Instruction: \B{Inst}} \\
        \hline
        \multicolumn{3}{c}{\B{Blk} \alt \B{VarD} \alt \B{If} \alt \B{BEq} \alt } \\
        \multicolumn{3}{c}{\B{Call} \alt \B{While} \alt \B{Case}} \\
        \hline
        \multicolumn{3}{|c|}{Block: \B{Blk}} \\
        \hline
        \B{body} & : & seq \B{Inst} \\
        \hline
        \multicolumn{3}{|c|}{Variable declaration: \B{VarD}} \\
        \hline
        \B{vars} & : & seq \B{Name} \\
        \B{body} & : & seq \B{Inst} \\
        \hline
        \multicolumn{3}{|c|}{If: \B{If}} \\
        \hline
        \B{branches} & : & seq \B{IfBr} \\
        \hline
        \multicolumn{3}{|c|}{Becomes equal: \B{Beq}} \\
        \hline
        \B{lhs} & : & \B{Name} \\
        \B{rhs} & : & \B{Expr} \\
        \hline
        \multicolumn{3}{|c|}{Operation call: \B{Call}} \\
        \hline
        \B{op} & : & \B{Name} \\
        \B{pre} & : & opt \B{Name} \\
        \B{inp} & : & seq \B{Expr} \\
        \B{out} & : & seq \B{Name}
        \\
	\hline
	\multicolumn{3}{|c|}{While loop: \B{While}} \\
        \hline
        \B{cond} & : & \B{Pred} \\
        \B{body} & : & \B{Inst}
        \\
%         \\
%         \hline
%         \multicolumn{3}{|c|}{Case conditional: \B{Case}} \\
%         \hline
%         \B{expr} & : & \B{Expr} \\
%         \B{branches} & : & seq \B{CaseBr}
      \end{tabular}
      & &
      \begin{tabular}[t]{rcl}
        \hline
        \multicolumn{3}{|c|}{If branch: \B{IfBr}} \\
        \hline
        \B{cond} & : & opt \B{Pred} \\
        \B{body} & : & \B{Inst} \\
%         \hline
%         \multicolumn{3}{|c|}{Case branch: \B{CaseBr}} \\
%         \hline
%         \B{val} & : & seq \B{Value} \\
%         \B{body} & : & \B{Inst} \\
        \hline
        \multicolumn{3}{|c|}{Expression: \B{Expr}} \\
        \hline
        \multicolumn{3}{c} {\B{Lit} \alt \B{Term} \alt \B{Pred}} \\
        \hline
        \multicolumn{3}{|c|}{Term expression: \B{Term}} \\
        \hline
        \B{op} & : & \B{ArithOp} \\
        \B{args} & : & seq \B{Exp} \\
        \hline
        \multicolumn{3}{|c|}{Predicate: \B{Pred}} \\
        \hline
        \multicolumn{3}{c}{\B{Form} \alt \B{Comp}} \\
        \hline
        \multicolumn{3}{|c|}{Boolean formula: \B{Form}} \\
        \hline
        \B{op} & : & \B{BoolOp} \\
        \B{args} & : & seq \B{Pred} \\
        \hline
        \multicolumn{3}{|c|}{Comparison: \B{Comp}} \\
        \hline
        \B{op} & : & \B{RelOp} \\
        \B{arg1}, \B{arg2} & : & \B{Exp} \\
        \hline
        \multicolumn{3}{|c|}{Data type: \B{Type}} \\
        \hline
        \multicolumn{3}{c}{\B{INT} \alt \B{BOOL}}
      \end{tabular}
    \end{tabular}
  }
  }
    \caption{Abstract syntax structure of a B implementation.  For each abstract
      syntax element, we give the name of the class  or a list of the possible sub-classes.
      Sequence and optional attributes are denoted ``seq'' and ``opt'', respectively.}
    \label{tab:node-attr}
  \end{center}
\end{figure}

\section{Target LLVM Subset}
\label{sec:llvm}

LLVM aims to be a general, language agnostic, intermediate representation for
compilers. The compiler front-end translates the source programming language to
LLVM source code, upon which optimization and other static analysis tasks may
be performed, and the compiler back-end translates to the target platform
assembly language. One key feature of LLVM is that it is a single-static
assignment (SSA) language: a variable may only be assigned once. So for each
assignment to a variable found in the source language, the front-end shall
generate a new temporary variable in the LLVM program. For illustration,
figure~\ref{fig:ex-llvm} presents a B specification, C program and a LLVM
program with two temporary variables \llvm{\%0} and \llvm{\%1}.
\begin{figure}
\vspace*{-2.3em}
  \begin{minipage}[t]{.3\textwidth}
    \begin{tabbing}
      foo \= \kill  \\
%      \B{VARIABLES}\\
%      \> y\\
      inc(x) =\\
      \B{PRE} x : INT \B{THEN}   \\
      \> 	y := x+y\\
      \B{END} \\
      \end{tabbing}
  \end{minipage}
  \:\vline\:
  \begin{minipage}[t]{.2\textwidth}
    \begin{tabbing}
      foo \= \kill  \\
%	 int y;\\      
      void inc(int x) \{\\
      \> 	y = x+y; \\
      \}\end{tabbing}
  \end{minipage}
	  \:\vline\:
  \begin{minipage}[t]{.6\textwidth}
    \begin{tabbing}
      foo \= \kill  \\
%	 \llvm{@y = global i32 0 } \\      
      \llvm{define void @inc(i32 \%x) nounwind \{} \\
      \llvm{entry:}                      \\
      \> \llvm{\%0 = load i32* @y, align 4}     \\
      \> \llvm{\%1 = add nsw i32 \%0, \%x}     \\
      \> \llvm{store i32 \%1, i32* @y, align 4} \\
      \> \llvm{ret void} \\
      \llvm{\}}
    \end{tabbing}

  \end{minipage}
  \caption{Simple example of a B function and its corresponding  C function and LLVM function.
    It is simplified and not a faithful translation, but it helps to understand the translation. 
    The first line in LLVM code contains the signature: return type \llvm{void}, the name
    \llvm{@inc} and one parameter named \llvm{\%x} and typed \llvm{i32}.  Next
    is the body with a single block, labeled \llvm{entry}, and temporary
    variables \llvm{\%0} and \llvm{\%1}, created in the conversion to SSA. The
    block has four instructions: \llvm{load}, \llvm{add}, \llvm{store} and
    \llvm{ret}. For instance, \llvm{\%1 = add nsw i32 \%0, \%x} is an addition
    (\llvm{add}), has result type \llvm{i32} and assigns to \llvm{\%1} the sum
    of variable \llvm{\%0} and  variable \llvm{\%x}, the result is stored in
     \llvm{@y}.}
  \label{fig:ex-llvm}
\end{figure}

Operations and instructions are translated to LLVM instructions as discussed in
sec.~\ref{sec:control}. For reason of reduced space, only the operations and
instructions will be presented with more details.

Code generation is defined with a set of rules defined by structural
recursion. For each grammatical construct, a code generation function is
defined: $\trad{~}{\B{Oper}}$ for operations, $\trad{~}{\B{Inst}}$ for
instructions, $\trad{~}{\B{Expr}}$ for expressions and so forth. Each such
function usually produces a text corresponding to bits of LLVM source code. It
may have additional parameter and results. The symbol $\sep$ is used to clearly
separate composed results. Auxiliary functions are introduced for
conveniency. To abbreviate the presentation, we denote
$\trad{~}{\ListOf{\B{A}}}$ as the translation function for sequences of \B{A}
elements, defined as the concatenation of the application of $\trad{~}{\B{A}}$
to the elements of the sequence.

In those rules, $\PH{t}$ indicates a text place-holder where the value of $t$
shall be inserted and $\nl$ denotes a new line. For instance, we define
$\local(\B{n}) \isdef \llvm{"\%\PH{\B{n.id}}"}$ as a function that given an
element \B{n} of the abstract syntax tree returns the corresponding LLVM local
name, obtained by prepending character \% to its identifier. We assume an 
unlimited supply of labels and local variables: let $\name$ return a fresh LLVM
label or local variable name.

\section{Translation: Operations
\label{sec:control}}

This section addresses how operations in B implementations are translated to
LLVM functions. For operations, the presentation of the translation
is divided into three steps: the signature, the local data, and the body
instructions.

The signature of the function is composed of the name of the function, the
result type, the name and type of the parameters. The signature may carry other
information such as linkage, visibility, calling convention, etc. The B parser
provides this information after the type checking phase has been completed.  On
the one hand LLVM functions may only have one result, on the other hand B0
operations may produce several results. The translation of output parameters
will be function parameters passed by reference, i.e. they are pointers. For
uniformity of treatment, the return type of the produced LLVM functions is
\llvm{void}.

The \trad{}{sig} rule specifies the translation of operation headers and
\trad{}{alloc} rule defines the LLVM stack allocation.  The results of the
translation of each aspect are combined as follows:
\begin{align*}
\begin{split}
  \lefteqn{\trad{\B{op}}{\B{oper}} \isdef} \\
  & \LET h = \trad{\B{op}}{sig} \AND   a = \trad{\B{op.body}}{alloc} \AND i = \trad{\B{op.body}, \llvm{exit}}{\ListOf{\B{Inst}}}_L \IN  \\
  & \llvm{"define void \PH{h} \{\nl} \\
  & \quad \llvm{entry:\nl} \\
  & \quad \quad \PH{a}  \quad \quad \PH{i}  \\
%  & \quad \quad \PH{i} \\
  & \quad \llvm{exit: ret void\nl} \\
  & \llvm{\}\nl"}
\end{split}
\end{align*}

\subsection{Translation of instructions}
\label{sec:trad-instr}

Function $\trad{\B{il}, $\ell$}{\ListOf{\B{Inst}}}_L$ takes as input a sequence
of B instructions \B{il} and a label $\ell$ and produces the source code of a
LLVM block with $\ell$ as exit point. It is defined as follows:

\begin{align*}
\trad{\B{il}, $\ell$}{\ListOf{\B{Inst}}}_L \isdef & \IF \B{il} \mbox{ is empty} \THEN \llvm{"br \PH{\ell} \nl"} \\
& \ELSE \LET i, il' = il  \AND p = \trad{il, $\ell$}{\ListOf{\B{Inst}}}_L \IN \\
& \quad \IF i \mbox{ is \B{If} or \B{While}} \THEN \LET \ell' = \name \IN \llvm{"\PH{\trad{i, $\ell'$}{\B{Inst}}} \PH{\ell'}: \PH{p}"} \\
& \quad \ELSE \llvm{"\PH{\trad{i}{\B{Inst}}} \PH{p}"}
\end{align*}

Eventually, $\trad{}{\B{Inst}}$ defines the translation for individual
instructions. Its definition is specialized for each class of instructions as
detailed in the rest of this section. Note that a new block is created after
each \B{If} and \B{While} instruction.

\paragraph{While instructions} are translated in two blocks of instructions:
block $\ell_1$ evaluates the loop condition and block $\ell_2$ executes the loop
body:
\begin{align*}
\begin{split}
\trad{w, $\ell$}{\B{While}} \isdef 
  & \LET \ell_1 = \name \AND \ell_2 = \name \AND c \sep v = \trad{w.cond}{\B{Pred}} \IN \\
  & \llvm{"\PH{\ell_1} : \PH{c}} \\
  & \llvm{br i1 \PH{v}, label \PH{\ell_2}, label \PH{\ell} \nl} \\
  & \llvm{\PH{\ell_2} : \PH{\trad{i.body, $\ell_1$}{\ListOf{\B{Inst}}}_L}}
\end{split}
\end{align*}

\paragraph{Becomes equal instructions} must evaluate the target and the source
of the assignment, and then copy the result of the latter in the former, using
the LLVM instruction \llvm{store}. The evaluation of the target is defined with
$\trad{}{lv}$, which yields the corresponding LLVM source code $l$ and the
variable $p$ containing the assigned location. The evaluation of the source
yields the corresponding code $r$, the variable $v$ holding the result, and its
type $t$.
\begin{align*}
\begin{split}
  \trad{a}{\B{Beq}} \isdef 
  & \LET l \sep p = \trad{i.lhs}{lv} \AND r \sep v \sep t = \trad{i.rhs}{\B{Expr}} \IN \\
  & \llvm{"\PH{l}} \\
  & \llvm{\PH{r}} \\
  & \llvm{store \PH{t} \PH{v}, \PH{t}* \PH{p} \nl"}
%   & l \conc r \conc 
%   \llvm{"store "} \conc t \conc \texttt{" "} \conc v \conc \llvm{", "}
%   \conc t \conc \llvm{"* "} \conc p \conc \nl
\end{split}
\end{align*}

\section{Conclusion and future work}
\label{sec:conclusion}

This paper presents the formal specification of a translation from a large
subset of the B implementation language to LLVM, a modern compiler internal
language.  Even though this is still a work in progress, the definition is
self-contained and has a large enough scope to be applied to B implementations
where the data belongs to basic types. This specification is a blueprint for a
code synthesis tool for B that is currently being implemented. This tool will be
distributed as an extension to Atelier-B under an open-source license.

The next step is to extend the scope to the full B implementation language. This
entails that the translation must be defined for aggregate data types and
adapted to handle some syntactic sugar. We are also planning for producing a
LLVM output with debugging information. Such output would be indeed very helpful
to provide feedback to the user when applying testing to validate the produced
code.

To prove the verification of the correctness of the translation, we would have
to define the semantics of both LLVM and B in a unified framework. One possible
starting point is Vellvm~\cite{vellvm}, a framework to reason about the
correctness of LLVM programs and transformations. We would then have to extend
the framework to include B implementation language. Another possible approach
would be to translate verification conditions from the B development artifacts
as assertinons in the generated LLVM code. The compiled program would include
checks that such assertions hold while executing.

\bibliographystyle{plain}
\bibliography{b2llvm}

\end{document}

