

\subsection{Translation of structures and arrays}
\label{sec:StructArray}

Two approaches are possible to support arrays and structures. An approach is 
importing reusable libraries of AtelierB that are reported in the official 
document of ClearSy\footnote{\url{http://www.atelierb.eu/ressources/DOC/english/reusable-components-reference.pdf}}. 
This approach is supported, but the generated code is more complex and it needs 
more intermediate steps to manipulate the data of imported components. 
Moreover, this approach allows dynamic allocation for arrays, but it is 
strongly not recommended for safety-critical systems. A second approach enjoys 
the direct correspondence between B0 native types and LLVM and this approach 
is presented here. This section describes the translation of derived data 
types showed in section~\ref{sec:data}.


\subsubsection{Structure} 
The structure declaration defines a list of variables to be placed under one 
name, allowing several variables to be accessed by one base name. This example  
initializes a structure, and gets and sets one value of xx'balance. 

Initializing a record with a sequence of expressions:
\[
  \textcolor{gray}{accountRecord :=}  \underbrace{rec(\underbrace{name:xx’name, balance:(xx’balance - amt)}_{seq\ Exp})}_{Record}
\]

Setting a record field to a variable:
\[
  \textcolor{gray}{xx :=}  \underbrace{accountRecord'balance}_{RecField} 
\]

A B code example:

\begin{pascalcode}
xx := rec(id:1, balance:10);
xx'balance := xx'balance-1;
\end{pascalcode}

The lines 1 and 2 are represented in translation in LLVM code:

\begin{llvmcode}
%1 = getelementptr %struct.R_1* @Rec__account, i32 0, i32 0
store i32 1, i32 * %1
%2 = getelementptr %struct.R_1* @Rec__account, i32 0, i32 1
store i32 10, i32 * %2

%3 = getelementptr %struct.R_1* @Rec__account, i32 0, i32 1
%4 = load i32* %3
%5 = sub nsw i32 %4, 1
%6 = getelementptr %struct.R_1* @Rec__account, i32 0, i32 1
store i32 %5, i32* %6
\end{llvmcode}

The $RecField$ rule gets an element value from the record. The same rule is 
used on the left side of attribution as a $LValue$ and right side of 
attribution as an $Expression$. The functions \SBPos(n) and \SBType(n)  get 
respectively the position and type of $n$ element in the structure. 

\begin{align*}
\begin{split}
  \trad{n}{\B{RecField}} \isdef \\
   &\LET \ell = \lbl  \AND  t = n.type \AND v = \B{head}(n.element) \AND\\
   &code \BE \llvm{"\PH{\ell} = getelementptr \PH{t}* \PH{v}, i32 0, i32  \SBPos(\B{n})\nl"} \IN \\
   &\IF \B{n.base.type} \mbox{ is \B{BOOL or NAT or INT} \AND n.element.length=1}\\
   &\quad \THEN  code \sep  \ell  \sep \SBType(\B{n})\\
   &\IF \B{n.base.type} \mbox{ is \B{RecField} }  \THEN \\
   &\LET \ell2 = \lbl  \AND  t = n.type \AND v = \B{tail}(n.element) \AND \\
   &\quad n2.base  \BE ?? \AND n2.element = \B{head}(n.element) \AND a, b, c = \trad{n2}{RecField}
\IN\\
   &\quad  code \conc  \llvm{"\PH{\ell2} = getelementptr \PH{t}* \PH{\ell}, i32 0, i32  \SBPos(\B{n})\nl"} \\
   &\quad \sep  \ell2  \sep \SBType(\B{n})\\
\end{split}
\end{align*}

The attribution from record structure to a record structure variable, line 1 
from last B code example, is translated by a sequence of application of rule 
$RecField$. The nested structures will be designed in the next project phase.
%TODO after test the first examples.

\subsubsection{Arrays}

The arrays store a fixed-size sequential collection of elements with the same type. 
They consist of contiguous memory locations, where the lowest address (0) 
corresponds to the first element and the highest address to the last element.
In B, a concrete array is a total function where the domain indexes the range 
elements. 

%[[ Write a text here to define the rule for it]]

There are three attributions cases related to array.
\begin{description}

\item[Case 1.1] - Initializing an unique value to an array:
\[
\textcolor{gray}{arr :=} \underbrace{\{\underbrace{\underbrace{0..2 \times 0..2 \times 0..3  }_{seq\ Exp} \times \underbrace{\{5\}}_{Exp} }_{Product}\}}_{Array}
\]
\item[Case 1.2] - Initializing different values to an array\footnote{B0 definition requires the declaration of all values.}:
\[
\textcolor{gray}{arr:=} \underbrace{\{\underbrace{(\underbrace{(0 \mapsto 0) \mapsto  0)}_{seq Exp} \mapsto \underbrace{5}_{Exp} , ... ,
(\underbrace{(2 \mapsto 2) \mapsto  3)}_{seq\ Exp} \mapsto \underbrace{5}_{Exp} }_{seq\ Map}\}}_{Array}
\]

Theses cases use a declared constant that is attributed to the variable:
\begin{llvmcode}
@array = global [3 x [3 x [4 x i32]]] 
[[3 x [4 x i32]] 
	[[4 x i32] [i32 5, i32 5, i32 5, i32 5], 
	 [4 x i32] [i32 5, i32 5, i32 5, i32 5], 
	 [4 x i32] [i32 5, i32 5, i32 5, i32 5]], 
 [3 x [4 x i32]] 
	[[4 x i32] [i32 5, i32 5, i32 5, i32 5],
	 [4 x i32] [i32 5, i32 5, i32 5, i32 5],
 	 [4 x i32] [i32 5, i32 5, i32 5, i32 5]],
 [3 x [4 x i32]] 
	[[4 x i32] [i32 5, i32 5, i32 5, i32 5],
	 [4 x i32] [i32 5, i32 5, i32 5, i32 5], 
	 [4 x i32] [i32 5, i32 5, i32 5, i32 5]]], align 16
\end{llvmcode}


The rule for declare array constants:


\begin{align*}
\begin{split}
  \trad{array}{\B{Type}} \isdef \\
   & \LET \quad \IF \B{array} \mbox{ is \B{Product} } \THEN \\
   & \quad \quad  dec = \trad{\llvm{"i32"}, array.arg1, array.arg2}{\B{Product}}\\
   & \quad \ELSIF array \mbox{ is \B{Map} } \THEN\\
   & \quad \quad  dec = \trad{\llvm{"i32"}, array.arg1, array.arg2}{\B{Map}} \\
   & \quad \IN \llvm{" global \PH{dec}"}\\
\end{split}
\end{align*}
\VGM{Alguma sugestão com relação as funções:head, tail.}

\begin{align*}
\begin{split}
  \trad{type, seqIntl, value}{\B{Product}} \isdef \\
   &\LET \B{h = head(seqIntl)} \AND\\
   & \B{times = h.end - h.start + 1} \AND\\
   & values = \trad{times,type,value}{\B{TV}} \IN\\
   & \IF \B{seqIntl.length} == 1 \THEN  \\
   & \llvm{"[\PH{times} x \PH{type}] [\PH{values}]"}  \\
   & \ELSE \LET \\
   &  tvalues = \trad{type,tail(seqIntl),values}{\B{Product}} \\
   & \IN \\
   & \llvm{"[\PH{times} x \PH{type}]  \PH{tvalues}"}  \\
\end{split}
\end{align*}

\begin{align*}
\begin{split}
  \trad{times, type, value}{\B{TV}} \isdef \\
   &\LET res1 = \llvm{" \PH{type} \PH{value} "} \IN\\
   & \IF times == 1 \THEN \llvm{"\PH{res1}"} \\
   & \ELSE \LET   res2 =   \trad{times-1,type,value}{\B{TV}}  \IN  \\
   & \llvm{"\PH{res1} , \PH{res2}"} \\
\end{split}
\end{align*}



The ``head'' function returns the first element from sequence.
The ``tail'' function returns the given sequence without its first element.



\begin{comment}
\$VarName = global [size X type] X [(type value,)^+]

|array|Type = LET
				  IF array is Product THEN dec = |array.arg1, array.arg2 |CProduct  ( Quebrando o padrão?)
				  ELSEIF array is seq Map THEN dec = |array.Map |Map
				IN	  
					" global "^ dec
				END
|sIntl, value |CProduct = 
    	IF sIntl is  empty THEN  ""
	ELSE THEN
		LET sizeType = |sIntl, "i32"|PrintSizeType &
		 tailSizeType=|sIntl.tail,"i32"|PrintSizeType & 
		 values= |tailSizeType,values|CProduct IN
		"[sizeType]  [ tailSizeType  values ]"		
		END
	END
	
|sIntl,t| PrintSizeType =
    	IF sIntl.size == 1  THEN  "t"
	ELSE THEN
		LET size = sIntl.head.size()  &
			type = |sIntl.tail,t| PrintSizeType    &
		"[size X type ]"		
		END
	END

|array|Type = IF t is Map THEN ...
\end{comment}




\item[Case 2.1] - Updating a selected element from array by a value of variable:
\[  \underbrace{\underbrace{arr}_{Array}(\underbrace{1+ii,1+jj,1+xx}_{seq\ Exp})}_{ArrayItem} \textcolor{gray}{:= xx}
\]
\item[Case 2.2] - Setting a selected element from array to a variable:
\[ 
\textcolor{gray}{xx :=} \underbrace{\underbrace{arr}_{Array}(\underbrace{1+ii,1+jj,1+xx}_{seq\ Exp})}_{ArrayItem}
\]
\item[Case 3] - Attribution between arrays\footnote{B0 definition requires the same type.}:
\[
\underbrace{arr1}_{Array} := \underbrace{arr2}_{Array} 
\]
\end{description}



\subsubsection{Relation arrays B0 and LLVM}

The arrays in B0 are represented by functions where an index points to an 
element. By default, the element of index not initialized has a zero value.
The different ways to evaluate an array are described as follow:

\subsubsection{Initialing an array}
The following two attribution commands have the same semantic effect.
 
\begin{pascalcode}
array2 := ( 0..1 * 0..1 * 0..3 * {5});

array2 := { 0|->0|->0|->5 , 0|->0|->1|->5 , 
            0|->1|->0|->5 , 0|->1|->1|->5 , 
            1|->0|->0|->5 , 1|->0|->1|->5 , 
            1|->1|->0|->5 , 1|->1|->1|->5 ,
            0|->0|->2|->5 , 0|->0|->3|->5 ,
            0|->1|->2|->5 , 0|->1|->3|->5 , 
            1|->0|->2|->5 , 1|->0|->3|->5 , 
            1|->1|->2|->5 , 1|->1|->3|->5 };
\end{pascalcode}

An alternative way to represent these attributions cannot be using sequential attributions as follow:

\begin{pascalcode}
array2(0,0,0) := 5;
array2(0,0,1) := 5;
// ... - A sequence of attributions
array2(1,1,3) := 5;
\end{pascalcode}

It is not possible, because B array attribution are atomic. The B array 
attribution are made in two steps. First, the new value is calculated and
copied to a temporal place. Second, the sequence of new values are setted 
in theirs address. Finally, considering these steps and the execution of
following code then the value of ``array2(0,0,1)'' is ``2''.

\begin{pascalcode}
 array2 := ( (0..1) * (0..1) * (0..3) * {1});
 array2 := { 0|->0|->0|->2 , 0|->0|->1|->(array2(0,0,0)+1), ...  };
\end{pascalcode}

The LLVM instruction \textit{getelementptr} is used to select an element in
the array or structure. A simple example is: 

\begin{llvmcode}
%7 = getelementptr [2 x [2 x [4 x i32]]]* @Array2, i32 0, i64 1, i64 1, i64 3
\end{llvmcode}


The first two parameters define the type and name of the variable, and the
others are indexes to select the element in the data type. The third parameter (i32 0)
selects the first element in the pointer (* @array2). The last elements 
(i64 1, i64 1, i64 3) select the value from position (1,1,3) storing it in \%7.
This array is multidimensional, so several indexes must be declared separated
by comma to get the specific element.

\subsubsection{Setting and getting array}

The following blocks illustrate a B code setting a value to array
and its translation to LLVM. 

\begin{pascalcode} 
VAR xx, yy, zz IN
	xx=1;
	yy=1;
	zz=3;
	array2(x,y,z):=7
END
\end{pascalcode}

This example is translated in four steps. First, the variables \%x, \%y, \%z 
are allocated. Second, the respective values 0, 1, 3 are stored in variables. 
Third, the variables are loaded to local variables and converted to 64 bits. 
Finally, the address of array is calculated in local variable \%7 and the value 
7 is stored in it.  
\begin{figure}[h]
\begin{llvmcode}
%xx = alloca i32
%yy = alloca i32
%zz = alloca i32
store i32 1, i32* %xx
store i32 1, i32* %yy
store i32 3, i32* %zz
%1 = load i32* %zz
%2 = sext i32 %1 to i64
%3 = load i32* %yy
%4 = sext i32 %3 to i64
%5 = load i32* %xx
%6 = sext i32 %5 to i64
%7 = getelementptr[2x[2x[4xi32]]]*@Array2,i32 0,i64 %6,i64 %4,i64 %2;getting an element
store i32 7, i32* %7         ;setting an element
\end{llvmcode}
\end{figure}


\subsubsection{Rules for support array}

\paragraph{Product} declares all address and a unique value from array, it is represented by \textbf{case 1.1}.

\paragraph{seq Map} declares every address and values from array, it is represented by \textbf{case 1.2}.



\paragraph{Array item} selects an item in expressions as ``$a(n1,...,n_{n})$'', 
where $a$ is $n.base$ and $n1,...,n_{n}$ is a sequence of indexes that 
calculates the address of element. This rule also supports to translate 
expressions of arrays. This rule is used to support array attributions 
from \textbf{cases} \textbf{2.1} and \textbf{2.2}.

\begin{align*}
\lefteqn{\trad{n}{ArrayItem} \isdef} \\
&  \LET p_1 \sep v_1 \sep t_1  = \trad{n.base}{Exp}  \IN \\
&  \LET r \sep p_2  = \trad{n.indexes}{LRExp}  \IN \\
&  \LET v =  \variable \AND  t = \trad{\B{n.type}}{Type}  \IN \\
&  \llvm{"\PH{p_1} \PH{p_2} \PH{v} =  getelementptr \PH{t_1}, \PH{v_1}, i32 0 \PH{r}\nl"}  \sep v \sep t\\
\end{align*}

A list of type and variable is generated by the following rule.
\begin{align*}
&\trad{n}{LRExp} \isdef \LET p \sep v \sep t  = \trad{n}{ShiftExp}  \IN  \llvm{",\PH{t} \PH{v} "} \sep p\\
&\trad{n l}{LRExp} \isdef \LET r_1 \sep p_1 = \trad{n}{LRExp} \AND
 \LET r_2 \sep p_2 = \trad{l}{LRExp} \IN\\
& \quad  \llvm{"\PH{r_1} \PH{r_2}"} \sep \llvm{"\PH{p_1} \PH{p_2}"}\\
\end{align*}


The element access of array can need a shift in indexes. When the domain of 
array is an interval and it is not started from zero, it must adjust the 
indexes shifting the access, because the addressing  of array in intermediate 
representation LLVM starts at 0. To access an element from array the formula is 
$address(e(i1,..,in))  = i1-i1\_start, ... , in-in\_start$. The following rule 
\footnote{The function $TSymbol$ returns the ``start'', ``end'' and type of the one 
index.} makes the shift for each index of array. \VGM{TODO: The function TSymbol
returns the ``start'', ``end'' and type of the one index.}

\begin{align*}
&\trad{n}{ShiftExp} \isdef \LET p \sep v \sep t  = \trad{n}{Exp} \AND \\
&\quad iStart \sep iEnd \sep iType = \trad{n}{TSymbol}  \AND  \PH{\ell} = \lbl \IN \\
&\quad \IF ( iStart == 0 ) \THEN  \llvm{",\PH{t} \PH{v} "} \sep p \\
&\quad \ELSE \LET  p' \sep v \sep v' \sep t'  = \trad{t,v,itype,istart}{Cast} \IN \\
&\quad \llvm{",\PH{t} \PH{\ell} "} \sep  \llvm{"\PH{p} \PH{p'}  \PH{\ell} = sub \PH{t'} \PH{v}, \PH{v'}\nl"}  \\
\end{align*}

The \trad{}{ShiftExp} rule does a subtraction and this operation must have operators with the same data types so the following cast rule is used:

\begin{align*}
&\trad{t,v,t',v'}{Cast} \isdef \LET  \ell = \lbl \IN \\
&\quad \IF ( t == t') \THEN p \sep v \sep v' \sep t  \\
&\quad \ELSE \IF (t<t') \THEN \\
&\quad \quad \llvm{"\PH{\ell}= bitcast \PH{t} \PH{v} , \PH{t'}\nl"}  \sep l \sep v' \sep t'\\ 
&\quad \ELSE \\ 
&\quad \quad \llvm{"\PH{\ell}= bitcast \PH{t'} \PH{v'} , \PH{t}\nl"} \sep v \sep l \sep t \\ 
\end{align*}



\paragraph{Relevant translation restrictions:}
\begin{itemize}
\item  B0 definition - An array must be initialized declaring all values 
to avoid no determinism.
\item B0 definition from CommenC - The operator overwrite from arrays is not supported, for example:

\begin{pascalcode}
array := array <+ {1|->2|->0|->4,  1|->2|->1|->5}
\end{pascalcode}

\end{itemize}


