\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage[fleqn]{amsmath}
\usepackage{xspace,framed,here,keystroke}
\usepackage{graphicx}
\usepackage[colorlinks=false]{hyperref}

\usepackage{minted}   %Used to syntax highlight
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\newminted{llvm}{frame=single,firstnumber=1,linenos=true,fontsize=\scriptsize,bgcolor=bg}
\newminted{pascal}{frame=single,firstnumber=1,linenos=true,fontsize=\scriptsize,bgcolor=bg}
\newminted{c}{frame=single,firstnumber=1,linenos=true,fontsize=\scriptsize,bgcolor=bg}



\newcommand{\trad}[2]{\ensuremath{\lVert \textsf{#1} \rVert^{\textit{#2}}}}
\newcommand{\nl}[0]{\ensuremath{\downarrow}}
\newcommand{\mty}[0]{\texttt{""}}
\DeclareMathOperator{\conc}{\diamond}
\DeclareMathOperator{\isdef}{\equiv}
\DeclareMathOperator{\dom}{\mbox{dom}}
\DeclareMathOperator{\lbl}{\mathcal{L}()}
\DeclareMathOperator{\variable}{\mathcal{V}()}
\newcommand{\llvm}[1]{\texttt{#1}}
\newcommand{\B}[1]{\textsf{#1}}
\newcommand{\lalt}[0]{$\langle$\xspace}
\newcommand{\ralt}[0]{$\rangle$\xspace}
\newcommand{\alt}[0]{$\mid\,$}
\newcommand{\ListOf}[1]{$\mbox{#1}^+$}
\newcommand{\nt}[1]{{\normalfont\textit{#1}}}
\newcommand{\Dict}[0]{\mathbb{D}}
\newcommand{\Text}[0]{\mathbb{T}}
\newcommand{\IF}[0]{\textbf{ if }}
\newcommand{\ELSIF}[0]{\textbf{ else if }}
\newcommand{\ELSE}[0]{\textbf{ else }}
\newcommand{\THEN}[0]{\textbf{ then }}
\newcommand{\LET}[0]{\textbf{ let }}
\newcommand{\IN}[0]{\textbf{ in }}
\newcommand{\AND}[0]{\textbf{ and }}
\newcommand{\PH}[1]{\framebox{$#1$}}
\newcommand{\sep}[0]{\otimes}
\newcommand{\intf}[0]{\ensuremath{\mathbb{I}}}
\newcommand{\Global}[0]{\ensuremath{\sf\Gamma}}
\newcommand{\local}[0]{\ensuremath{\sf\lambda}}
\newcommand{\opmap}[0]{\ensuremath{\sf\Omega}}
\newcommand{\developed}[0]{\ensuremath{\textsf{developed}}}
\newcommand{\stateless}[0]{\ensuremath{\textsf{stateless}}}
\newcommand{\importedmodules}[0]{\ensuremath{\textsf{i-mod}}}
\newcommand{\trimportedmodules}[0]{\ensuremath{\textsf{i-mod$\mathsf{\ast}$}}}
\newcommand{\importedinstances}[0]{\ensuremath{\textsf{i-inst}}}
\newcommand{\trimportedinstances}[0]{\ensuremath{\textsf{i-inst$\mathsf{\ast}$}}}
\newcommand{\idx}[0]{\ensuremath{\sf\Pi}}
\newcommand{\state}[0]{\ensuremath{\sf\Theta}}
\newcommand{\self}[0]{\ensuremath{\sf\Sigma}}
\newcommand{\init}[0]{\ensuremath{\mathsf{I}}}
\newcommand{\tradi}[2]{\ensuremath{\langle \textsf{#1} \rangle^{\textit{#2}}}}
\newcommand{\SBPos}[0]{\ensuremath{\sf\varphi}}
\newcommand{\SBType}[0]{\ensuremath{\sf\tau}}

\newcommand{\DD}[1]{\marginpar{\tiny{DD: #1}}}
\newcommand{\VGM}[1]{\marginpar{\tiny{VGM: #1}}}

 
\author{David Déharbe, Valério Medeiros Jr.}
\title{Specification of Advanced Types Translation}

\begin{document}



\usemintedstyle{friendly}

\section{The abstract syntax tree with support for advanced types}

The supported advanced types are array and structures. The nodes Array and 
Structure can be used to declare a variable, or  declare an element, or to 
select an element in the array or the structure. 

\begin{figure}[H]
  \begin{center}
    {\scriptsize
      \frame{
    \begin{tabular}[t]{ccc}
      \begin{tabular}[t]{rcl}
        \hline
        \multicolumn{3}{|c|}{Machine: \B{Machine}} \\
        \hline
        \B{id} & : & \B{Name} \\
        \B{const} & : & seq \B{Cons} \\
        \B{var} & : & seq \B{Vari} \\
        \B{init} & : & seq \B{Inst} \\
        \B{op} & : & seq \B{Oper} \\
        \B{impl} & : & opt \B{Impl} \\
        \hline
        \multicolumn{3}{|c|}{Implementation: \B{Impl}} \\
        \hline
        \B{id} & : & \B{Name} \\
        \B{impo} & : & seq \B{Import} \\
        \B{const} & : & seq \B{Cons} \\
        \B{var} & : & seq \B{Vari} \\
        \B{init} & : & seq \B{Inst} \\
        \B{op} & : & seq \B{Oper} \\
        \hline
        \multicolumn{3}{|c|}{Imports: \B{Import}} \\
        \hline
        \B{mach} & : & \B{Machine} \\
        \B{pre} & : & opt \B{Name}
        \\
        \hline
        \multicolumn{3}{|c|}{Constant: \B{Cons}} \\
        \hline
        \B{id} & : & \B{Name} \\
        \B{type} & : & \B{Type} \\
        \B{val} & : & \B{Value} \\
        \hline
        \multicolumn{3}{|c|}{Variable: \B{Vari}} \\
        \hline
        \B{id} & : & \B{Name} \\
        \B{type} & : & \B{Type} \\
        \B{scope} & : & \B{Impl} \alt \B{Oper}\\
	\hline
        \multicolumn{3}{|c|}{Operation: \B{Oper}} \\
        \hline
        \B{id} & : & \B{Name} \\
        \B{inp} & : & seq \B{Vari} \\
        \B{out} & : & seq \B{Vari} \\
        \B{body} & : & \B{Inst}
        \\
       \hline
        \multicolumn{3}{|c|}{Instruction: \B{Inst}} \\
        \hline
        \multicolumn{3}{c}{\B{Blk} \alt \B{VarD} \alt \B{If} \alt \B{BEq} \alt } \\
        \multicolumn{3}{c}{\B{Call} \alt \B{While} \alt \B{Case} \alt \B{Skip}} \\
        \hline
        \multicolumn{3}{|c|}{Block: \B{Blk}} \\
        \hline
        \B{body} & : & seq \B{Inst} \\
        \hline
        \multicolumn{3}{|c|}{Variable declaration: \B{VarD}} \\
        \hline
        \B{vars} & : & seq \B{Name} \\
        \B{body} & : & seq \B{Inst} \\
\end{tabular}
\begin{tabular}[t]{rcl}   
  	\hline
        \multicolumn{3}{|c|}{If: \B{If}} \\
        \hline
        \B{branches} & : & seq \B{IfBr} \\
        \hline
        \multicolumn{3}{|c|}{Becomes equal: \B{Beq}} \\
        \hline
        \B{lhs} & : & \B{LValue} \\
        \B{rhs} & : & \B{Exp} \\
	\hline
	\multicolumn{3}{|c|}{Left value: \B{LValue}} \\	
	\hline
	\multicolumn{3}{c}{ \B{Vari} \alt \B{ArrayItem} \alt \B{StructItem} }\\
        \hline
        \multicolumn{3}{|c|}{Operation call: \B{Call}} \\
        \hline
        \B{op} & : & \B{Oper} \\
        \B{inp} & : & seq \B{Exp} \\
        \B{out} & : & seq \B{Name} \\
        \B{inst} & : & opt \B{Impo} \\
        \hline
        \multicolumn{3}{|c|}{Case conditional: \B{Case}} \\
        \hline
        \B{expr} & : & \B{Exp} \\
        \B{branches} & : & seq \B{CaseBr}\\
	\hline
        \multicolumn{3}{|c|}{Case branch: \B{CaseBr}} \\
        \hline
        \B{val} & : & seq \B{Value} \\
        \B{body} & : & \B{Inst}
        \\
        \hline
        \multicolumn{3}{|c|}{While loop: \B{While}} \\
        \hline
        \B{cond} & : & \B{Pred} \\
        \B{body} & : & \B{Inst} \\
        \hline
        \multicolumn{3}{|c|}{If branch: \B{IfBr}} \\
        \hline
        \B{cond} & : & opt \B{Pred} \\
        \B{body} & : & \B{Inst} \\
        \hline
        \multicolumn{3}{|c|}{Expression: \B{Exp}} \\
        \hline
        \multicolumn{3}{c}{\B{Lit}\alt\B{Term}\alt\B{Pred}\alt\B{Cons}\alt\B{Vari}}\\
	\multicolumn{3}{c}{\B{Record}\alt\B{Array}\alt\B{ValueItem} } \\
        \hline
        \multicolumn{3}{|c|}{Value item : \B{ValueItem}} \\
        \hline
	\multicolumn{3}{c}{\B{StructItem}\alt\B{ArrayItem} } \\
        \hline
        \multicolumn{3}{|c|}{Term expression: \B{Term}} \\
        \hline
        \B{op} & : & \B{ArithOp} \\
        \B{args} & : & seq \B{Exp} \\
	\hline
        \multicolumn{3}{|c|}{Predicate: \B{Pred}} \\
        \hline
        \multicolumn{3}{c}{\B{Form} \alt \B{Comp}} \\
	\hline
        \multicolumn{3}{|c|}{Boolean formula: \B{Form}} \\
        \hline
        \B{op} & : & \B{BoolOp} \\
        \B{args} & : & seq \B{Pred} \\
\end{tabular} 
       
\begin{tabular}[t]{rcl}
	\hline
        \multicolumn{3}{|c|}{Comparison: \B{Comp}} \\
        \hline
        \B{op} & : & \B{RelOp} \\
        \B{arg1}, \B{arg2} & : & \B{Exp} \\
        \hline
        \multicolumn{3}{|c|}{Data type: \B{Type}} \\
        \hline
        \multicolumn{3}{c}{\B{INT} \alt \B{BOOL}\alt}\\
	\multicolumn{3}{c}{\B{StructType} \alt \B{ArrayType}}\\
	\hline
  	\multicolumn{3}{|c|}{Data struct : \B{StructType}} \\
        \hline
        \B{elements} & : & seq \B{Name} \\
	\B{type} & : & seq \B{Type}\\
	\hline
	\multicolumn{3}{|c|}{Access struct : \B{StructItem}} \\
        \hline
	\B{base} & : &  \B{Name} \\
	\B{element} & : & seq \B{Name}\\
	\B{type} & : & \B{Type}\\
	\hline
	\multicolumn{3}{|c|}{Record struct : \B{Record}} \\
        \hline
	\B{elements} & : & seq \B{Name}\\
	\B{values} & : & seq \B{Exp}\\
	\hline
        \multicolumn{3}{|c|}{Array type : \B{ArrayType}} \\
        \hline 
	\B{dom} & : & seq \B{Set}\\
	\B{ran} & : & \B{Set}\\
        \hline
        \multicolumn{3}{|c|}{Array expression : \B{Array}} \\
        \hline
	\multicolumn{3}{c}{ seq \B{Map} \alt \B{Product} \alt \B{Name}  }\\
	\hline
  	\multicolumn{3}{|c|}{Ordered pair : \B{Map}} \\
        \hline
	\B{arg1} & : & seq \B{Exp}\\ 
	\B{arg2} & : & \B{Exp}\\ 
	\hline
  	\multicolumn{3}{|c|}{Cartesian product : \B{Product}} \\
        \hline
	\B{arg1} & : & seq \B{Exp}\\ 
	\B{arg2} & : & \B{Exp}\\ 	
	\hline
	\multicolumn{3}{|c|}{Access array : \B{ArrayItem}} \\
        \hline
	\B{base} & : &  \B{Array} \\
	\B{indexes} & : & seq \B{Exp}\\
	\B{type} & : & \B{ArrayType}\\
	\hline
	\multicolumn{3}{|c|}{Simple set : \B{Set}} \\
	\hline
	\multicolumn{3}{c}{\B{BOOL} \alt \B{NAT} \alt \B{NAT$_{1}$}\alt } \\
	\multicolumn{3}{c}{\B{INT} \alt \B{Interval}} \\
	\hline
	\multicolumn{3}{|c|}{B0 interval : \B{Interval}} \\
	\hline
	\B{start}, \B{end} & : & \B{Exp} \\
	\hline
	\multicolumn{3}{|c|}{Literal : \B{Lit}} \\
	\hline
	\multicolumn{3}{c}{ \B{Bool\_lit} \alt \B{Int\_lit}} \\ 
      \end{tabular}
    \end{tabular}
  }
  }
    \caption{Abstract syntax structure of a B implementation.  For each abstract
      syntax element, we give the name of the class (e.g. \B{CaseBr} for a
      branch in a case instruction, and the different attributes of the class),
      or a list of the possible sub-classes (e.g. \B{Inst} for the different
      kinds of instructions).
      Sequence and optional attributes are denoted ``seq'' and ``opt'',
      respectively.}
    \label{tab:node-attr}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \begin{tabular}{rcl}
      \nt{module} & ::= & \ListOf{\nt{item}} \\
      \nt{item} & ::= & \nt{const\_decl} \alt \nt{function\_decl} \alt \nt{type\_def}
      \alt \nt{const\_def} \alt \nt{var\_def} \alt \nt{function\_def} \\
      \nt{const\_decl} & ::= & \nt{name} \llvm{=} \llvm{external} \llvm{constant} \nt{type} \\
      \nt{type\_def} & ::= & \nt{name} \llvm{=} \llvm{type} \nt{type} \\
      \nt{type} & ::= & \llvm{void} \alt \nt{itype} \alt \llvm{\{} \ListOf{\nt{type}} \llvm{\}} \alt \nt{type}\llvm{*} \\
      \nt{const\_def} & ::= & \nt{name} \llvm{=} \llvm{constant} \nt{type} \nt{iliteral} \\
      \nt{var\_def} & ::= & \nt{name} \llvm{=} \llvm{common} \llvm{global} \nt{type} \llvm{zeroinitializer} \\
      \nt{function\_decl} & ::= & \llvm{declare} \nt{type} \nt{name} \llvm{(} \ListOf{\nt{type}} \llvm{)}\\
      \nt{function\_def} & ::= & \llvm{define} \nt{type} \nt{name} \llvm{(} \ListOf{\nt{param}} \llvm{)} \llvm{\{} \ListOf{\nt{block}} \llvm{\}} \\
      \nt{param} & ::= & \nt{type} \nt{name} \\
      \nt{block} & ::= & \nt{lbl} \llvm{:} \ListOf{\nt{inst}} \\
      \nt{inst} & ::=  & \nt{name} \llvm{=} \llvm{alloca} \nt{type} \\
      & \alt & \nt{name} \llvm{=} \lalt \llvm{add} \alt \llvm{sub} \alt \llvm{mul} \alt \llvm{sdiv} \alt \llvm{srem} \ralt \nt{itype} \nt{exp} \llvm{,} \nt{exp} \\
      & \alt & \nt{name} \llvm{=} \llvm{icmp} \lalt \llvm{eq} \alt \llvm{ne} \alt \llvm{sgt} \alt \llvm{sge} \alt \llvm{slt} \alt \llvm{sle} \ralt \llvm{i1} \nt{exp} \llvm{,} \nt{exp}\\
      & \alt & \nt{name} \llvm{=} \llvm{call} \nt{type} \llvm{(} \ListOf{\nt{arg}} \llvm{)} \\
      & \alt & \nt{name} \llvm{=} \llvm{getelementptr} \nt{type} \llvm{*} 
\nt{exp}\llvm{,} \nt{index}\llvm{,} \ListOf{\nt{index}} \\
      & \alt & \nt{name} \llvm{=} \llvm{load} \nt{type} \nt{exp} \\
      & \alt & \llvm{store} \nt{type} \nt{exp}, \nt{type} \llvm{*} \nt{exp} \\
      & \alt & \nt{name} \llvm{=} \llvm{bitcast} \nt{type} \nt{name}, \nt{type} \\
      & \alt & \llvm{br} \llvm{i1} \nt{exp} \llvm{,} \llvm{label} \nt{lbl} \llvm{,} \llvm{label} \nt{lbl} \\
      & \alt & \llvm{br} \llvm{label} \nt{lbl} \\
%       & \alt & \llvm{switch} \nt{type} \nt{exp} \llvm{,} \llvm{branch} \nt{lbl} \llvm{[} \ListOf{\nt{branch}} \llvm{]} \\
      & \alt & \llvm{ret} \lalt \nt{type} \nt{exp} \alt \llvm{void} \ralt \\
      \nt{exp} & ::= & \nt{name} \alt \nt{iliteral} \alt \llvm{getelementptr} 
\llvm{(} \nt{type} \nt{exp} \llvm{,} \nt{index} \llvm{,} \ListOf{\nt{index}} \llvm{)} \\
      \nt{index} & ::= & \nt{itype} \nt{iliteral} \\
      \nt{branch} & ::= & \nt{iliteral} \nt{iliteral} \nt{lbl} \\
      \nt{arg} & ::= & \nt{type} \nt{exp}
    \end{tabular}
  \end{center}
  \caption{Grammar of the target LLVM subset: \nt{itype}, \nt{iliteral}, \nt{lbl}
    and \nt{name} correspond respectively to integer types, integer literals,
    labels and names. Choices are separated by \alt and optionally delimited by
    \lalt and \ralt.  The \ListOf{} superscript denotes a comma-separated list of
    elements of the annotated entity. }
  \label{fig:llvm-grammar}
\end{figure}

\VGM{To support arrays and structures, I added only + after index.} 



\subsection{Rules to be updated in first specification}

\paragraph{Becomes equal instructions} must evaluate the target and the source
of the assignment, and then copy the result of the latter in the former, using
the LLVM instruction \llvm{store}. The evaluation of the target is defined with
$\trad{}{lvalue}$, which yields the corresponding LLVM source code $l$ and the
variable $p$ containing the assigned location. The evaluation of the source
yields the corresponding code $r$, the variable $v$ holding the result, and its
type $t$. 

\begin{align*}
\begin{split}
  \trad{a}{\B{Beq}} \isdef
  & \LET l \sep p \sep t'= \trad{a.lhs}{lvalue} \AND r \sep v \sep t = \trad{a.rhs}{\B{Exp}} \IN \\
  & \llvm{"\PH{l}} \\
  & \llvm{\PH{r}} \\
  & \llvm{store \PH{t} \PH{v}, \PH{t'} \PH{p} \nl"}
\end{split}
\end{align*}

The rule lvalue is:
\begin{align*}
\lefteqn{\trad{n}{lvalue} \isdef} \\
& \LET t = \llvm{"\PH{\trad{\B{n.type}}{Type}}"} \IN \\
& \quad \IF \mbox{\B{n} is a local variable} \THEN \llvm{""} \sep \local(\B{n}) \sep t \\
& \quad \IF \mbox{\B{n} is an ArrayItem} \THEN  \trad{n}{ArrayItem} \\
& \quad \IF \mbox{\B{n} is a StructItem} \THEN  \trad{n}{StructItem} \\
& \quad \ELSE \LET v = \variable \IN \\
& \quad \quad \llvm{"\PH{v} = getelementptr \PH{\state(\B{n.root})}* \%self\$,} \\
& \quad \quad \quad \llvm{i32 0, i32 \PH{\idx(\B{n})} \nl"} \sep v \sep t
\end{align*}

The expressions have elements represented by pointers that need a special 
care. The attributions between these elements are made  directly by the memory 
address.  However, the expression resolution are made by parts, where the 
partial results are stored to temporary variables. Therefore, the expression 
resolution with pointers needs an additional instruction $LOAD$ for store the 
partial results. This translation is represented by $ValueItem$.

\begin{align*}
\begin{split}
  \trad{n}{\B{ValueItem}} \isdef \\
   & \LET \ell = \lbl  \IN\\
   & \IF \B{n} \mbox{ is \B{StructItem}} \THEN p' \sep v' \sep t' = \trad{\B{n}}{\B{StructItem}} \\
   & \ELSIF \B{n} \mbox{ is \B{ArrayItem}} \THEN p' \sep v' \sep t' = \trad{\B{n}}{\B{ArrayItem}} \\
   & \llvm{"\PH{p'} \PH{\ell}  = load  \PH{t'}* \PH{v'} \nl"} \\
   & \sep  \ell  \sep t'\\
\end{split}
\end{align*}


\section{Translation of Structures and Array}

Two approaches are possible to support arrays and structures. An approach is 
importing reusable libraries of AtelierB that are reported in the official 
document of ClearSy\footnote{\url{http://www.atelierb.eu/ressources/DOC/english/reusable-components-reference.pdf}}. 
This approach is supported, but the generated code is more complex and it needs 
more intermediate steps to manipulate the data of imported components. 
Moreover, this approach allows dynamic allocation for arrays, but it is 
strongly not recommended for safety-critical systems. A second approach enjoys 
the direct correspondence between B0 native types and LLVM and this approach 
is presented here.

\subsection{Structure} \VGM{It is not implemented yet, because it requires generating an XML example.}
The structure declaration defines a list of variables to be placed under one 
name, allowing several variables to be accessed by one base name. This example  
initializes a structure, and gets and sets one value of xx'balance. 
 
\begin{ccode}
xx := rec(id:1, balance:10);
xx'balance := xx'balance -1;
\end{ccode}
The lines 1 and 2 are represented in translation in LLVM code:

\begin{llvmcode}
%1 = getelementptr %struct.R_1* @Rec__account, i32 0, i32 0
store i32 1, i32 * %1
%2 = getelementptr %struct.R_1* @Rec__account, i32 0, i32 1
store i32 10, i32 * %2

%3 = getelementptr %struct.R_1* @Rec__account, i32 0, i32 1
%4 = load i32* %3
%5 = sub nsw i32 %4, 1
%6 = getelementptr %struct.R_1* @Rec__account, i32 0, i32 1
store i32 %5, i32* %6
\end{llvmcode}

The $StructItem$ rule gets an element value from the struct. The same rule is used on the left side of attribution as a $LValue$ and right side of attribution as an $Expression$. The functions \SBPos(n) and \SBType(n)  get respectively the position and type of $n$ element in the structure. 

\begin{align*}
\begin{split}
  \trad{n}{\B{StructItem}} \isdef \\
   & \IF \B{n.type} \mbox{ is \B{BOOL or NAT or INT} } \THEN \\
   &\quad  \LET \ell = \lbl  \AND  \PH{t} = n.type \AND \PH{v} = n.element \IN\\
   &\quad  \llvm{"\PH{\ell} = getelementptr \%\PH{t}* @\PH{v}, i32 0, i32  \SBPos(\B{n})\nl"} \\
   &\quad  \sep  \ell  \sep \SBType(\B{n})\\
\end{split}
\end{align*}

The attribution from record structure to a structure variable, line 1 from last 
B code example, is translated by a sequence of application of rule $StructItem$.


\section{Arrays}

The arrays store a fixed-size sequential collection of elements with the same type. 
They consist of contiguous memory locations, where the lowest address (0) 
corresponds to the first element and the highest address to the last element.
In B, a concrete array is a total function where the domain indexes the range 
elements. Declaration examples of arrays are:
\begin{itemize}
	\item $array1 \in (0..10) \to INT $	(a simple array)
	\item $array2 \in (1..10) \times (1..20) \times (1..30) \to INT $   (a multidimensional array)
	\item $\{1\vdash1\vdash4, 1\vdash2\vdash5\}  \in (INT \times INT) \times INT$ (an initialised array)
\end{itemize} 


\subsection{Relation arrays B0 and LLVM}

The arrays in B0 are represented by functions where an index points to an 
element. By default, the element of index not initialized has a zero value. 

This section shows the relation between arrays B0 and LLVM. The sequence of
elements are defining an array, getting an element and setting an
element.

\subsubsection{Declaring an array}


The essential elements of the array are its name, size and type. 
The size of ``e'' array with the indexes (i1,...,in) are defined according 
to the formula:\\
 $size(e) = (e.i1\_end - e.i1\_star+1) * ... * (e.in\_end - e.in\_start+1)$.

The following code declares a multidimensional global array called ``Array2'' 
with 6000 (10*20*30) integer numbers with 32 bits and initialized with zero.

\begin{llvmcode}
@Array2 = internal global [10 x [20 x [30 x i32]]] zeroinitializer, align 16
\end{llvmcode}

\VGM{It is not implemented yet, because it requires generating an XML example.}
The following example initialises an new array in C:

\begin{ccode}
int32_t arr[1][2][1]= {{{4},{5}}};
\end{ccode}

The syntax rule\footnote{The underlined element type can be expanded in others types definitions.} used to initialize an array in LLVM is:\\
$@<var\_name> = constant [<size> x \underline{<type>}] [<type> <value>]$.\\
The translation of the last example is:

\begin{llvmcode}
@arr=constant[1 x [2 x [1 x i32]]] [[2 x [1 x i32]] [[1 x i32] [i32 4],[1 x i32] [i32 5]]]
\end{llvmcode}


\subsubsection{Getting an element from array}

The LLVM instruction \textit{getelementptr} is used to select an element in
the array or structure. A simple example is: 

\begin{llvmcode}
%7 = getelementptr [10 x [20 x [30 x i32]]]* @Array2, i32 0, i64 2, i64 3, i64 4
\end{llvmcode}


The first parameter defines the type and name of the variable, and the others are
indexes to select the element in the data type. The second parameter (i32 0)
selects the first element in the pointer (* @Array2). The last elements 
(i64 2, i64 3, i64 4) select the value from position (2,3,4) storing it in \%7.
This array is multidimensional, so several indexes must be declared separated
by comma to get the specific element.

\subsubsection{Setting and getting array}

The following blocks illustrate a C code setting a value to array
and its translation to LLVM. 

\begin{ccode} 
int x=2; int y=3; int z=4;
Array2[x][y][z]=7;
\end{ccode}

This example is translated in four steps. First, the variables \%x, \%y, \%z 
are allocated. Second, the respective values 2, 3, 4 are stored in variables. 
Third, the variables are loaded to local variables and converted to 64 bits. 
Finally, the address of array is calculated in local variable \%7 and the value 
7 is stored in it.  
\begin{figure}[h]
\begin{llvmcode}
%x = alloca i32
%y = alloca i32
%z = alloca i32
store i32 2, i32* %x
store i32 3, i32* %y
store i32 4, i32* %z
%1 = load i32* %z
%2 = sext i32 %1 to i64
%3 = load i32* %y
%4 = sext i32 %3 to i64
%5 = load i32* %x
%6 = sext i32 %5 to i64
%7 = getelementptr[10x[20x[30xi32]]]*@Array2,i32 0,i64 %6,i64 %4,i64 %2;getting an element
store i32 7, i32* %7         ;setting an element
\end{llvmcode}
\end{figure}

\subsection{Rules for support Array}


\paragraph{Array item} selects an item in expressions as ``$a(n1,...,n_{n})$'', 
where $a$ is $n.base$ and $n1,...,n_{n}$ is a sequence of indexes that 
calculates the address of element. This rule also supports to translate 
expressions of arrays.

\begin{align*}
\lefteqn{\trad{n}{ArrayItem} \isdef} \\
&  \LET p_1 \sep v_1 \sep t_1  = \trad{n.base}{Exp}  \IN \\
&  \LET r \sep p_2  = \trad{n.indexes}{LRExp}  \IN \\
&  \LET v =  \variable \AND  t = \trad{\B{n.type}}{Type}  \IN \\
&  \llvm{"\PH{p_1} \PH{p_2} \PH{v} =  getelementptr \PH{t_1}, \PH{v_1}, i32 0 \PH{r}\nl"}  \sep v \sep t\\
\end{align*}

A list of type and variable is generated by the following rule.
\begin{align*}
&\trad{n}{LRExp} \isdef \LET p \sep v \sep t  = \trad{n}{ShiftExp}  \IN  \llvm{",\PH{t} \PH{v} "} \sep p\\
&\trad{n l}{LRExp} \isdef \LET r_1 \sep p_1 = \trad{n}{LRExp} \AND 
 \LET r_2 \sep p_2 = \trad{l}{LRExp} \IN\\
& \quad  \llvm{"\PH{r_1} \PH{r_2}"} \sep \llvm{"\PH{p_1} \PH{p_2}"}\\
\end{align*}


The element access of array can need a shift in indexes. When the domain of 
array is an interval and it is not started from zero, it must adjust the 
indexes shifting the access, because the addressing  of array in intermediate 
representation LLVM starts at 0. To access an element from array the formula is 
$address(e(i1,..,in))  = i1-i1\_start, ... , in-in\_start$. The following rule 
\footnote{The function $TSymbol$ returns the ``start'', ``end'' and type of the one 
index.} makes the shift for each index of array. \VGM{TODO: The function TSymbol
returns the ``start'', ``end'' and type of the one index.}

\begin{align*}
&\trad{n}{ShiftExp} \isdef \LET p \sep v \sep t  = \trad{n}{Exp} \AND \\
&\quad iStart \sep iEnd \sep iType = \trad{n}{TSymbol}  \AND  \ell = \lbl \IN \\
&\quad \IF ( iStart == 0 ) \THEN  \llvm{",\PH{t} \PH{v} "} \sep p \\
&\quad \ELSE \LET  p \sep v \sep v' \sep t'  = \trad{p,t,v,itype,istart}{Cast} \IN \\
&\quad \llvm{",\PH{t} \PH{l} "} \sep  \llvm{"\PH{p} \PH{\ell} = sub \PH{t'} \PH{v}, \PH{v'}\nl"}  \\
\end{align*}

The \trad{}{ShiftExp} rule does a subtraction and this operation must have operators with the same data types so the following cast rule is used:

\begin{align*}
&\trad{p,t,v,t',v'}{Cast} \isdef \LET  \ell = \lbl \IN \\
&\quad \IF ( t == t') \THEN p \sep v \sep v' \sep t  \\
&\quad \ELSE \IF (t<t') \THEN \\
&\quad \quad \llvm{"\PH{p} \PH{l}= bitcast \PH{t} \PH{v} , \PH{t'}\nl"}  \sep l \sep v' \sep t'\\ 
&\quad \ELSE \\ 
&\quad \quad \llvm{"\PH{p} \PH{l}= bitcast \PH{t'} \PH{v'} , \PH{t}\nl"} \sep v \sep l \sep t \\ 
\end{align*}

\paragraph{Restriction on array:} The translation of direct attribution
 between arrays is not yet supported, for example:

\begin{pascalcode}
 array1 := array2;
\end{pascalcode}


\section*{Attachments}

\subsection{Structure examples}

The following code example is defining a structure:


\begin{ccode}
MACHINE Rec
SETS
 ID={aa,bb}
VARIABLES xx, bank, total
INVARIANT
 xx : struct(name : ID, balance : NAT) & bank : struct(name : ID) &
 total:struct(money:NAT)
INITIALISATION 
 bank := rec(name:bb) ||
 xx:= rec(name:aa, balance:10) ||
 total := rec(money:20)
OPERATIONS

  res<--positive = 
  PRE xx'balance > 0 THEN
  res:=TRUE
  END;

  withrdaw(amt) = 
  PRE amt:NAT1 & (xx'balance >= amt) THEN
     xx := rec(name:xx'name, balance:(xx'balance - amt))
  END;
  
  unsafe_dec = 
  BEGIN
       xx'balance := xx'balance - 1
  END
END
\end{ccode}


\begin{ccode}
IMPLEMENTATION
    Rec_i

REFINES
    Rec

CONCRETE_VARIABLES
   xx ,
   bank ,
   total

INITIALISATION
   
   bank := rec(name:bb) ;
   xx := rec(name:aa, balance:10) ;
   total :=rec(money:20)
OPERATIONS
  res<--positive = 
  IF xx'balance > 0 THEN
       res:= TRUE 
  ELSE res := FALSE
  END;

  withrdaw(amt) = IF   amt >=0 & amt <= MAXINT & (xx'balance >= amt) THEN 
     xx := rec(name:xx'name, balance:(xx'balance - amt))
  END;

  unsafe_dec = BEGIN
       xx'balance := xx'balance -1 
  END
END
\end{ccode}




\subsection{Arrays examples}

%\iffalse  % This content is not visible to reader.
A generic example available at repository ProB\footnote{
\url{https://github.com/bendisposto/probparsers/blob/develop/bparser/src/test/resources/parsable/Array.mch}}. 
This example can be used in approach using imported components.




\subsection{A  simple example and its LLVM}


\begin{ccode}
MACHINE
   Array
VARIABLES arr

INVARIANT 
    arr : ((0..99) --> 0..1000)

INITIALISATION arr := {1|->100}

OPERATIONS 

set(ix,tt)=
        PRE ix : (0..99) & tt : (0..1000)
        THEN arr := arr <+ {ix |-> tt}
        END ;

tt <-- read(ix) =
        PRE ix : (0..99)
        THEN tt := arr(ix)
        END;

swap(ix, jx)=
        PRE ix : (0..99) & jx : (0..99)
        THEN arr := arr <+ {ix |-> arr(jx), jx|-> arr(ix)}
        END

END
\end{ccode}

\begin{ccode}
IMPLEMENTATION 
   Array_i
REFINES
   Array
CONCRETE_VARIABLES
   arr
INVARIANT 
    arr :  ((0..99) --> 0..1000)
INITIALISATION
   arr(1) := 100
OPERATIONS
   set ( ix , tt ) =
   IF
       ix >= 0 & ix <=99 & tt >= 0  & tt <= 1000
   THEN
       
      arr(ix) := tt 
   END;

   tt <-- read ( ix ) =
   IF
       ix >= 0 & ix <=99
   THEN
       tt := arr ( ix )
   ELSE
       tt := 0
   END;

   swap ( ix , jx ) =
   IF
        ix >= 0 & ix <=99 & jx >= 0 & jx <=99 
   THEN

       VAR temp IN
           temp := arr(jx);
           arr(jx) := arr(ix);
           arr(ix) := temp
       END
   END
END
\end{ccode}




\begin{ccode}
@Array__arr = internal global [100 x i32] zeroinitializer, align 16

define void @Array__INITIALISATION() nounwind ssp {
  store i32 100, i32* getelementptr  ([100 x i32]* @Array__arr, i32 0, i64 1)
  ret void
}

define void @Array__set(i32 %ix, i32 %tt) nounwind ssp {
  %1 = alloca i32
  %2 = alloca i32
  store i32 %ix, i32* %1
  store i32 %tt, i32* %2
  %3 = load i32* %1
  %4 = icmp sge i32 %3, 0
  br i1 %4, label %5, label %19

; <label>:5                                       ; preds = %0
  %6 = load i32* %1
  %7 = icmp sle i32 %6, 99
  br i1 %7, label %8, label %19

; <label>:8                                       ; preds = %5
  %9 = load i32* %2
  %10 = icmp sge i32 %9, 0
  br i1 %10, label %11, label %19

; <label>:11                                      ; preds = %8
  %12 = load i32* %2
  %13 = icmp sle i32 %12, 1000
  br i1 %13, label %14, label %19

; <label>:14                                      ; preds = %11
  %15 = load i32* %2
  %16 = load i32* %1
  %17 = sext i32 %16 to i64
  %18 = getelementptr  [100 x i32]* @Array__arr, i32 0, i64 %17
  store i32 %15, i32* %18
  br label %19
; <label>:19                                      ; preds = %14, %11, %8, %5, %0
  ret void
}
\end{ccode}


\begin{llvmcode}
define void @Array__read(i32 %ix, i32* %tt) nounwind ssp {
  %1 = alloca i32, align 4
  %2 = alloca i32*, align 8
  store i32 %ix, i32* %1, align 4
  store i32* %tt, i32** %2, align 8
  %3 = load i32* %1, align 4
  %4 = icmp sge i32 %3, 0
  br i1 %4, label %5, label %14

; <label>:5                                       ; preds = %0
  %6 = load i32* %1, align 4
  %7 = icmp sle i32 %6, 99
  br i1 %7, label %8, label %14

; <label>:8                                       ; preds = %5
  %9 = load i32* %1, align 4
  %10 = sext i32 %9 to i64
  %11 = getelementptr  [100 x i32]* @Array__arr, i32 0, i64 %10
  %12 = load i32* %11
  %13 = load i32** %2, align 8
  store i32 %12, i32* %13
  br label %16

; <label>:14                                      ; preds = %5, %0
  %15 = load i32** %2, align 8
  store i32 0, i32* %15
  br label %16

; <label>:16                                      ; preds = %14, %8
  ret void
}
\end{llvmcode}


\begin{llvmcode}
define void @Array__swap(i32 %ix, i32 %jx) nounwind ssp {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %ix, i32* %1, align 4
  store i32 %jx, i32* %2, align 4
  %3 = load i32* %1, align 4
  %4 = icmp sge i32 %3, 0
  br i1 %4, label %5, label %30

; <label>:5                                       ; preds = %0
  %6 = load i32* %1, align 4
  %7 = icmp sle i32 %6, 99
  br i1 %7, label %8, label %30

; <label>:8                                       ; preds = %5
  %9 = load i32* %2, align 4
  %10 = icmp sge i32 %9, 0
  br i1 %10, label %11, label %30

; <label>:11                                      ; preds = %8
  %12 = load i32* %2, align 4
  %13 = icmp sle i32 %12, 99
  br i1 %13, label %14, label %30

; <label>:14                                      ; preds = %11
  %15 = load i32* %2, align 4
  %16 = sext i32 %15 to i64
  %17 = getelementptr  [100 x i32]* @Array__arr, i32 0, i64 %16
  %18 = load i32* %17
  store i32 %18, i32* %temp, align 4
  %19 = load i32* %1, align 4
  %20 = sext i32 %19 to i64
  %21 = getelementptr  [100 x i32]* @Array__arr, i32 0, i64 %20
  %22 = load i32* %21
  %23 = load i32* %2, align 4
  %24 = sext i32 %23 to i64
  %25 = getelementptr  [100 x i32]* @Array__arr, i32 0, i64 %24
  store i32 %22, i32* %25
  %26 = load i32* %temp, align 4
  %27 = load i32* %1, align 4
  %28 = sext i32 %27 to i64
  %29 = getelementptr  [100 x i32]* @Array__arr, i32 0, i64 %28
  store i32 %26, i32* %29
  br label %30

; <label>:30                                      ; preds = %14, %11, %8, %5, %0
  ret void
}

\end{llvmcode}




\subsection{Real example - Bubble Sort}

\begin{ccode}
MACHINE
   Bubble
VARIABLES
   vec,sort
INVARIANT
   vec : 0..99 --> 0..99 & sort : 0..1 &
   ( sort = 1 =>  !ii.(ii : 0..98 => vec(ii)<=vec(ii+1)))
INITIALISATION
   vec :: 0..99 --> 0..99 || sort := 0
OPERATIONS
   op_sort =
   ANY sorted_vector WHERE
    sorted_vector : 0..99 --> 0..99 &
    !ii.(ii : 0..98 => sorted_vector(ii)<=sorted_vector(ii+1))
   THEN
    vec := sorted_vector|| sort := 1
   END

END


IMPLEMENTATION
   Bubble_i
REFINES
   Bubble
CONCRETE_VARIABLES
   vec1,sort1
INVARIANT
   vec1 : 0..99 --> 0..99 & sort1 : 0..1 &
   vec = vec1 & sort1 = sort
INITIALISATION
   vec1(0) := 0  ;
   sort1 := 0
OPERATIONS
   op_sort =
   VAR nn, swapped, ii, tmp, vi, vi2 IN
	swapped := 1;
	nn := 100;
	ii:=0;
	WHILE swapped = 1 DO
		swapped := 0;
		ii:= 0;
		nn:= nn-1;

		WHILE ii<= nn DO
		vi :=  vec1(ii);
		vi2 := vec1(ii+1);
		IF vi > vi2 THEN
			tmp:= vec1(ii+1);
			vec1(ii+1):=vec1(ii);
			vec1(ii):=tmp;
			swapped:= 1
		END;
		ii:= ii+1

		INVARIANT 1>0
		VARIANT nn-ii
		END

	INVARIANT 1>0
	VARIANT nn-ii
	END
   END
END
\end{ccode}


\end{document}
